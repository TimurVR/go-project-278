import * as React from 'react';
import { useContext, useEffect, useRef } from 'react';
import { useNavigate as useReactRouterNavigate, useLocation, useParams, useBlocker, useMatch, useInRouterContext, Link, Navigate, Route, Routes, Outlet, matchPath, createHashRouter, RouterProvider as ReactRouterProvider, UNSAFE_DataRouterContext, UNSAFE_DataRouterStateContext, } from 'react-router-dom';
var routerProviderFuture = { v7_startTransition: false, v7_relativeSplatPath: false };
/**
 * Hook to check if navigation blocking is supported.
 * In react-router, blocking requires a data router.
 */
var useCanBlock = function () {
    var dataRouterContext = useContext(UNSAFE_DataRouterContext);
    var dataRouterStateContext = useContext(UNSAFE_DataRouterStateContext);
    return !!(dataRouterContext && dataRouterStateContext);
};
/**
 * Wrapper around react-router's useNavigate that returns a stable function reference.
 *
 * react-router's useNavigate forces rerenders on every navigation, even if we don't use the result.
 * @see https://github.com/remix-run/react-router/issues/7634
 *
 * This wrapper uses a ref to return a stable function reference, avoiding unnecessary rerenders
 * in components that use navigate but don't need to rerender on navigation.
 */
var useNavigate = function () {
    var navigate = useReactRouterNavigate();
    var navigateRef = useRef(navigate);
    useEffect(function () {
        navigateRef.current = navigate;
    }, [navigate]);
    // Return a stable function that always calls the latest navigate
    return React.useCallback(function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        return navigateRef.current.apply(navigateRef, args);
    }, []);
};
/**
 * Internal router component that creates a HashRouter.
 * Only used when not already inside a router context.
 */
var InternalRouter = function (_a) {
    var children = _a.children, basename = _a.basename;
    var router = createHashRouter([{ path: '*', element: React.createElement(React.Fragment, null, children) }], {
        basename: basename,
        future: {
            v7_fetcherPersist: false,
            v7_normalizeFormMethod: false,
            v7_partialHydration: false,
            v7_relativeSplatPath: false,
            v7_skipActionErrorRevalidation: false,
        },
    });
    return (React.createElement(ReactRouterProvider, { router: router, future: routerProviderFuture }));
};
/**
 * RouterWrapper component for react-router.
 * Creates a HashRouter if not already inside a router context.
 */
var RouterWrapper = function (_a) {
    var basename = _a.basename, children = _a.children;
    var isInRouter = useInRouterContext();
    if (isInRouter) {
        return React.createElement(React.Fragment, null, children);
    }
    return React.createElement(InternalRouter, { basename: basename }, children);
};
/**
 * Default router provider using react-router-dom.
 * This provider is used by default when no custom routerProvider is provided to <Admin>.
 */
export var reactRouterProvider = {
    // Hooks
    useNavigate: useNavigate,
    useLocation: useLocation,
    useParams: useParams,
    useBlocker: useBlocker,
    useMatch: useMatch,
    useInRouterContext: useInRouterContext,
    useCanBlock: useCanBlock,
    // Components
    Link: Link,
    Navigate: Navigate,
    Route: Route,
    Routes: Routes,
    Outlet: Outlet,
    // Router creation
    RouterWrapper: RouterWrapper,
    // Utilities
    matchPath: matchPath,
};
//# sourceMappingURL=reactRouterProvider.js.map